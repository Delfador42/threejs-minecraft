<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>demo</title>
    <style type="text/css">
        * {
            margin: 0;
            padding: 0;
        }

        html, body {
            overflow-x: hidden;
            overflow-y: hidden;
            height: 100%;
            width: 100%;
        }

        .canvas-frame {
            height: 100%;
            /*min-height: 400px;*/
            width: 100%;
            cursor: pointer;
        }
    </style>

</head>
<body>
<div id="canvas-frame" class="canvas-frame"></div>
<script type="module">
    import * as THREE from './base/three.module.js'
    import MCFirstPersonControl from "./utils/MCFirstPersonControl.js";
    import {WEBGL} from "./jsm/WebGL.js";
    import {TWEEN} from "./jsm/libs/tween.module.min.js";
    import CubeFactory from "./utils/CubeFactory.js";
    import StatsWindow from "./utils/Stats.js";
    import ShowOrbitControl from "./utils/ShowOrbitControl.js";

    let enableShadow = false;

    if (WEBGL.isWebGLAvailable() === false) {
        document.body.appendChild(WEBGL.getWebGLErrorMessage());
    }
    let canvasEL = document.getElementById("canvas-frame");

    let width = canvasEL.offsetWidth;
    let height = canvasEL.offsetHeight;

    // 舞台*
    let scene;
    (function initScene() {
        scene = new THREE.Scene();
        scene.name = 'SCENE';
        // scene.fog = new THREE.FogExp2( 0xffffff, 0.02 );//雾效果
    })();

    // 光源*
    let lightCurrentIntensity = 1;
    let lightValueChangeDirection = true;

    let lightAmbient;
    let lightDirectional;

    let lightHighIntensity = 1;
    let lightLowIntensity = 0.3;

    function getAmbientLightIntensity() {
        return Math.min(Math.max(lightLowIntensity, lightCurrentIntensity), lightHighIntensity) * 2 / 4;
    }

    function getDirectionalLightIntensity() {
        return Math.min(Math.max(0, lightCurrentIntensity), lightHighIntensity) / 4;
    }

    (function initLight() {
        lightAmbient = new THREE.AmbientLight(0xffffff, getAmbientLightIntensity());//环境光。让物体变亮
        scene.add(lightAmbient);
        lightDirectional = new THREE.DirectionalLight(0xffffff, getDirectionalLightIntensity());//平行光。制造明暗面，并不使方块变色严重
        lightDirectional.position.set(-100, 100, -100);
        lightDirectional.castShadow = enableShadow;
        lightDirectional.shadow.camera.near = 0; //产生阴影的最近距离
        lightDirectional.shadow.camera.far = 300; //产生阴影的最远距离
        lightDirectional.shadow.camera.left = -50; //产生阴影距离位置的最左边位置
        lightDirectional.shadow.camera.right = 50; //最右边
        lightDirectional.shadow.camera.top = 50; //最上边
        lightDirectional.shadow.camera.bottom = -50; //最下面
        //这两个值决定使用多少像素生成阴影 默认512
        lightDirectional.shadow.mapSize.height = 128;
        lightDirectional.shadow.mapSize.width = 128;
        scene.add(lightDirectional);
    })();

    // 相机*
    let camera;
    (function initCamera() {
        camera = new THREE.PerspectiveCamera(45, width / height, 0.01, 100000);//最远1e10
        camera.name = "CAMERA";
        camera.position.x = 10;
        camera.position.y = 10;
        camera.position.z = -10;
        // camera.lookAt(0, 0, 0);
    })();

    // 渲染器*
    let renderer;
    (function initRenderer() {
        renderer = new THREE.WebGLRenderer({
            antialias: true//是否开启反锯齿
        });
        renderer.name = 'RENDERER';
        renderer.shadowMap.enabled = enableShadow;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;//更柔和的影子，需要的性能更高
        renderer.setSize(width, height);
        document.getElementById('canvas-frame').appendChild(renderer.domElement);
        renderer.setClearColor(0xFFFFFF, 1.0);//背景颜色
    })();

    // 相机控制器
    let controls;
    let controlsType = "MCFirstPersonControl";
    let objects = [];
    (function initControls() {
        switch (controlsType) {
            case "ShowOrbitControl":
                let showOrbitControl = new ShowOrbitControl(camera, renderer.domElement);
                showOrbitControl.initClickFunction(scene.children);
                controls = showOrbitControl.controls;
                break;
            case "MCFirstPersonControl":
                let mcFirstPersonControl = new MCFirstPersonControl(camera, renderer.domElement, objects);
                mcFirstPersonControl.initClickFunction(scene.children);
                controls = mcFirstPersonControl;
                break;
        }
    })();


    //使渲染器与相机随窗口大小改变适应。自适应窗口大小
    window.onresize = function () {
        width = canvasEL.offsetWidth;
        height = canvasEL.offsetHeight;
        //更新相机视角比例
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
        renderer.setSize(width, height);
    };


    //--------------------------------------动作代码------------------------------------------
    //运动
    function actionMove(obj, actions) {
        let x = obj.position.x;
        let y = obj.position.y;
        let z = obj.position.z;
        let firstTween;
        let oldTween;
        for (let i in actions) {
            actions[i].properties.x = x + actions[i].properties.x;
            actions[i].properties.y = y + actions[i].properties.y;
            actions[i].properties.z = z + actions[i].properties.z;
            let newTween = new TWEEN.Tween(obj.position)
                .to(actions[i].properties, actions[i].duration || 1000)
                .easing(actions[i].easing)
            if (oldTween !== undefined) {
                oldTween.chain(newTween);
            }
            if (i === '0') {
                firstTween = newTween;
            }
            oldTween = newTween;
        }
        oldTween.chain(firstTween)
        return firstTween;
        // .to( { x: -4}, 3000 ).repeat( Infinity ).start();
    }

    let actions1 = [
        {
            properties: {
                x: 5, y: 0, z: 0
            },
            easing: TWEEN.Easing.Cubic.In
        }, {
            properties: {
                x: 0, y: 5, z: 0
            },
            easing: TWEEN.Easing.Exponential.InOut
        }, {
            properties: {
                x: 0, y: 0, z: 5
            },
            easing: TWEEN.Easing.Elastic.Out
        }
    ];

    //旋转
    function actionRotate(obj, x, y, z) {
        if (Array.isArray(obj)) {
            for (let e of obj) {
                e.rotation.x += x || 0;
                e.rotation.y += y || 0;
                e.rotation.z += z || 0;
            }
        } else {
            obj.geometry.needsUpdate = true;
            // texture4.needsUpdate=true;
            obj.rotation.x += x || 0;
            obj.rotation.y += y || 0;
            obj.rotation.z += z || 0;
        }
    }

    //旋转(三方向同速)
    function actionRotateXYZ(obj, xyz) {
        actionRotate(obj, xyz || 0.01, xyz || 0.01, xyz || 0.01)
    }

    //-----------以下为物体添加代码---------------------------------------------------------------
    function addLine(x1, y1, z1, x2, y2, z2, color) {
        x1 = x1 || 0;
        y1 = y1 || 0;
        z1 = z1 || 0;
        x2 = x2 || 0;
        y2 = y2 || 0;
        z2 = z2 || 0;
        color = color || 0xff0000;
        let startPoint = new THREE.Vector3(x1, y1, z1);
        let endPoint = new THREE.Vector3(x2, y2, z2);
        let geometry = new THREE.Geometry();
        geometry.vertices.push(startPoint);
        geometry.vertices.push(endPoint);
        let material = new THREE.MeshBasicMaterial({color: color});
        let line = new THREE.LineSegments(geometry, material, THREE.LinePieces);
        //  return line;
        scene.add(line);
    }

    //坐标线
    addLine(0, 0, 0, 10, 0, 0, 0xff0000);//中心坐标线，X轴，红
    addLine(0, 0, 0, 0, 10, 0, 0x00ff00);//中心坐标线，Y轴，绿
    addLine(0, 0, 0, 0, 0, 10, 0x0000ff);//中心坐标线，Z轴，蓝

    // 网格线
    (function () {
        const gridSize = 25;
        const lineWidth = 4;
        for (let i = 0; i <= gridSize * 2 / lineWidth; i++) {

            let geometry = new THREE.Geometry();
            geometry.vertices.push(new THREE.Vector3(-gridSize, 0, 0));
            geometry.vertices.push(new THREE.Vector3(gridSize, 0, 0));

            let lineX = new THREE.Line(geometry, new THREE.LineBasicMaterial({color: 0xcccccc, opacity: 0.2}));
            lineX.position.z = (i * lineWidth) - gridSize;
            lineX.position.y = 0.01;
            scene.add(lineX);

            let lineY = new THREE.Line(geometry, new THREE.LineBasicMaterial({color: 0xcccccc, opacity: 0.2}));
            lineY.position.x = (i * lineWidth) - gridSize;
            lineY.rotation.y = 90 * Math.PI / 180;   //  旋转90度
            lineY.position.y = 0.01;
            scene.add(lineY);

            // let lineZ = new THREE.Line(geometry, new THREE.LineBasicMaterial({color: 0x0000ff, opacity: 0.5}));
            // lineZ.position.x = (i * 4)-gridSize/2 ;
            // lineZ.rotation.z = 90 * Math.PI / 180;   //  旋转90度
            // scene.add(lineZ);
        }
    })();

    //平台底板
    (function addBasePlane() {
        let geometry = new THREE.CubeGeometry(50, 1, 50);
        let material = new THREE.MeshLambertMaterial({color: 0xffffff});
        let basePlaneMesh = new THREE.Mesh(geometry, material);
        basePlaneMesh.position.y = -0.5;
        basePlaneMesh.receiveShadow = enableShadow;
        scene.add(basePlaneMesh);
        objects.push(basePlaneMesh);
    })();

    //增加天空盒
    (function () {
        let backgroundType = 1;
        let textureCube = new THREE.CubeTextureLoader().load([
            'img/1.png',
            'img/2.png',
            'img/3.png',
            'img/4.png',
            'img/5.png',
            'img/6.png'
        ]);
        if (backgroundType === 1) {//使用场景背景添加
            scene.background = new THREE.Color(0x87CEEB);
        } else if (backgroundType === 2) {
            scene.background = textureCube
        } else {//使用盒子添加
            //着色器
            let cubeShader = THREE.ShaderLib["cube"];
            cubeShader.uniforms["tCube"].value = textureCube;
            let material = new THREE.ShaderMaterial({
                fragmentShader: cubeShader.fragmentShader,  //定义自己的片元着色器
                vertexShader: cubeShader.vertexShader,  //定义自己的顶点着色器
                uniforms: cubeShader.uniforms,  //给着色器传入uniform变量的值
                depthWrite: false,  //决定这个材质是否影响WebGL的深度缓存
                side: THREE.BackSide,  //侧面：反面
            });
            //创建方盒子
            let cubeWithPic = new THREE.Mesh(new THREE.CubeGeometry(1000000, 1000000, 1000000), material);
            scene.add(cubeWithPic);
        }
    })();


    function changeLight() {
        lightAmbient.intensity = getAmbientLightIntensity();
        lightDirectional.intensity = getDirectionalLightIntensity();
        if (lightValueChangeDirection) {
            if (lightCurrentIntensity >= lightLowIntensity - (lightHighIntensity - lightLowIntensity)) {
                lightCurrentIntensity -= 0.002;
            } else {
                lightValueChangeDirection = false;
            }
        } else {
            if (lightCurrentIntensity <= lightHighIntensity + (lightHighIntensity - lightLowIntensity)) {
                lightCurrentIntensity += 0.002;
            } else {
                if (lightCurrentIntensity > 1.5) {
                    lightValueChangeDirection = true;
                }
            }
        }
    }

    (function addGrassCubes() {
        let cubeFactory = new CubeFactory("GrassDirt");

        // let letterPositionInfo = {
        //     A: [
        //         [2, 0, 0],
        //         [3, 0, 0],
        //         [4, 0, 0],
        //         [5, 0, 0],
        //         [6, 0, 0],
        //         [1, 0, -1],
        //         [4, 0, -1],
        //         [0, 0, -2],
        //         [4, 0, -2],
        //         [1, 0, -3],
        //         [4, 0, -3],
        //         [2, 0, -4],
        //         [3, 0, -4],
        //         [4, 0, -4],
        //         [5, 0, -4],
        //         [6, 0, -4],
        //     ],
        //     B: [
        //         [0, 0, 0],
        //         [1, 0, 0],
        //         [2, 0, 0],
        //         [3, 0, 0],
        //         [4, 0, 0],
        //         [5, 0, 0],
        //         [6, 0, 0],
        //         [0, 0, -1],
        //         [3, 0, -1],
        //         [6, 0, -1],
        //         [0, 0, -2],
        //         [3, 0, -2],
        //         [6, 0, -2],
        //         [0, 0, -3],
        //         [3, 0, -3],
        //         [6, 0, -3],
        //         [1, 0, -4],
        //         [2, 0, -4],
        //         [4, 0, -4],
        //         [5, 0, -4],
        //     ],
        //     E: [
        //         [0, 0, 0],
        //         [1, 0, 0],
        //         [2, 0, 0],
        //         [3, 0, 0],
        //         [4, 0, 0],
        //         [5, 0, 0],
        //         [6, 0, 0],
        //         [0, 0, -1],
        //         [3, 0, -1],
        //         [6, 0, -1],
        //         [0, 0, -2],
        //         [3, 0, -2],
        //         [6, 0, -2],
        //         [0, 0, -3],
        //         [3, 0, -3],
        //         [6, 0, -3],
        //         [0, 0, -4],
        //         [6, 0, -4],
        //     ],
        //     G: [
        //         [1, 0, 0],
        //         [2, 0, 0],
        //         [3, 0, 0],
        //         [4, 0, 0],
        //         [5, 0, 0],
        //         [0, 0, -1],
        //         [6, 0, -1],
        //         [0, 0, -2],
        //         [6, 0, -2],
        //         [0, 0, -3],
        //         [4, 0, -3],
        //         [6, 0, -3],
        //         [1, 0, -4],
        //         [4, 0, -4],
        //         [5, 0, -4],
        //     ],
        //     I: [
        //         [0, 0, -1],
        //         [6, 0, -1],
        //         [0, 0, -2],
        //         [1, 0, -2],
        //         [2, 0, -2],
        //         [3, 0, -2],
        //         [4, 0, -2],
        //         [5, 0, -2],
        //         [6, 0, -2],
        //         [0, 0, -3],
        //         [6, 0, -3],
        //     ],
        //     M: [
        //         [0, 0, 0],
        //         [1, 0, 0],
        //         [2, 0, 0],
        //         [3, 0, 0],
        //         [4, 0, 0],
        //         [5, 0, 0],
        //         [6, 0, 0],
        //         [2, 0, -1],
        //         [3, 0, -2],
        //         [2, 0, -3],
        //         [0, 0, -4],
        //         [1, 0, -4],
        //         [2, 0, -4],
        //         [3, 0, -4],
        //         [4, 0, -4],
        //         [5, 0, -4],
        //         [6, 0, -4],
        //     ],
        //     N: [
        //         [0, 0, 0],
        //         [1, 0, 0],
        //         [2, 0, 0],
        //         [3, 0, 0],
        //         [4, 0, 0],
        //         [5, 0, 0],
        //         [6, 0, 0],
        //         [2, 0, -1],
        //         [3, 0, -2],
        //         [4, 0, -3],
        //         [0, 0, -4],
        //         [1, 0, -4],
        //         [2, 0, -4],
        //         [3, 0, -4],
        //         [4, 0, -4],
        //         [5, 0, -4],
        //         [6, 0, -4],
        //     ],
        //     T: [
        //         [0, 0, 0],
        //         [0, 0, -1],
        //         [0, 0, -2],
        //         [1, 0, -2],
        //         [2, 0, -2],
        //         [3, 0, -2],
        //         [4, 0, -2],
        //         [5, 0, -2],
        //         [6, 0, -2],
        //         [0, 0, -3],
        //         [0, 0, -4],
        //     ]
        // };
        // let word = "BEGIN";
        // let moveZ = 0;
        // for (let letter of word) {
        //     for (let cubePosition of letterPositionInfo[letter]) {
        //         let cube = cubeFactory.create(cubePosition[0], cubePosition[1], cubePosition[2] + moveZ);
        //         scene.add(cube);
        //         objects.push(cube);
        //     }
        //     moveZ -= 6;
        // }
        {
            let mountain = [];
            for (let x = 0; x < 5; x++) {
                for (let z = 0; z < 5; z++) {
                    if (x !== 2 || z !== 2) {
                        mountain.push([x, 0, z]);
                    }
                }
            }
            mountain.push([0, 1, 0]);
            for (let cubePosition of mountain) {
                let cube = cubeFactory.create(cubePosition[0] - 7, cubePosition[1], cubePosition[2]);
                scene.add(cube);
                objects.push(cube);
            }
        }

        {
            let mountainHeight = 6;
            let mountain = [];
            for (let y = 0; y < mountainHeight; y++) {
                for (let x = y; x < 2 * mountainHeight - y; x++) {
                    for (let z = y; z < 2 * mountainHeight - y; z++) {
                        mountain.push([x + 13, y, z - 10])
                    }
                }
            }
            mountain.push([0, 1, 0]);
            for (let cubePosition of mountain) {
                let cube = cubeFactory.create(cubePosition[0] - 7, cubePosition[1], cubePosition[2]);
                scene.add(cube);
                objects.push(cube);
            }
        }


        {
            let mountain = [];
            for (let x = 0; x < 5; x++) {
                for (let z = 0; z < 5; z++) {
                    for (let y = 0; y < 5; y++) {
                        if (y >= x)
                            mountain.push([x, y - x, z])
                    }
                }
            }
            for (let cubePosition of mountain) {
                let cube = cubeFactory.create(cubePosition[0] - 7, cubePosition[1], cubePosition[2] - 16);
                scene.add(cube);
                objects.push(cube);
            }
        }
        {
            let box = new THREE.Mesh(
                new THREE.CubeGeometry(2, 1, 2),
                new THREE.MeshPhongMaterial({color: 0xcccccc})
            );
            box.receiveShadow = box.castShadow = enableShadow;
            box.position.y = 3;
            box.position.x = -4;
            box.position.z = 0;
            scene.add(box);
            objects.push(box)
        }
        {
            let box = new THREE.Mesh(
                new THREE.CubeGeometry(2, 1, 2),
                new THREE.MeshPhongMaterial({color: 0xcccccc})
            );
            box.receiveShadow = box.castShadow = enableShadow;
            box.position.y = 8;
            box.position.x = camera.position.x;
            box.position.z = camera.position.z;
            scene.add(box);
            objects.push(box)
        }
    })();
    let prevTime = performance.now();

    (function animate() {
        requestAnimationFrame(animate);
        let time = performance.now();
        let delta = (time - prevTime) / 1000;
        prevTime = time;
        TWEEN.update(delta);
        controls.update(delta);
        renderer.render(scene, camera);
        new StatsWindow("canvas-frame").stats.update(delta);
        changeLight();
    })();

</script>
</body>
</html>
