<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>demo</title>
  <style type="text/css">
    * {
      margin: 0;
      padding: 0;
    }

    html, body {
      height: 100%;
      width: 100%;
      overflow: hidden;
    }

    .canvas-frame {
      height: 100%;
      width: 100%;
      border: none;
      cursor: pointer;
      background-color: #EEEEEE;
    }
  </style>
  <script src="js/three.js?t=1"></script>
  <!--浏览器支持检测-->
  <script src="utils/Detector.js"></script>
  <!--监控控件-->
  <script src="utils/stats.js"></script>
  <!--运动-->
  <script src="utils/tween.js"></script>
  <!--时钟材质-->
  <script src="utils/clock.js?t=2"></script>
  <!--鼠标控制摄像机-->
  <script src="utils/OrbitControls.js"></script>
</head>
<body>
<div id="canvas-frame" class="canvas-frame"></div>
<script>
  (function threeJsSupportCheck() {
    if (!Detector.webgl) {
      Detector.addGetWebGLMessage();
      return;
    }
  })();

  // let width = document.getElementById('canvas-frame').clientWidth;
  // let height = document.getElementById('canvas-frame').clientHeight;
  let width = window.innerWidth;
  let height = window.innerHeight;
  clock();


  // 舞台*
  let scene;

  function initScene() {
    scene = new THREE.Scene();
  }

  // 相机*
  let camera;
  let controls;

  function initCamera() {
    camera = new THREE.PerspectiveCamera(45, width / height, 0.01, 1e10);
    //使用TrackballControls不能设置相机位置
    camera.position.x = 30;
    camera.position.y = 30;
    camera.position.z = 30;

    //会使坐标系中此向量在屏幕中，显示为竖直向上
    // camera.up.x = 0;
    // camera.up.y = 1;
    // camera.up.z = 0;
    camera.lookAt(0, 0, 0);
    controls = new THREE.OrbitControls(camera);
    // 如果使用animate方法时，将此函数删除
    //controls.addEventListener( 'change', render );
    // 使动画循环使用时阻尼或自转 意思是否有惯性
    controls.enableDamping = true;
    //动态阻尼系数 就是鼠标拖拽旋转灵敏度
    controls.dampingFactor = 1.5;

  }

  // 渲染器*
  let renderer;

  function initRenderer() {
    renderer = new THREE.WebGLRenderer({
      antialias: true
    });
    renderer.setSize(width, height);
    document.getElementById('canvas-frame').appendChild(renderer.domElement);
    renderer.setClearColor(0xFFFFFF, 1.0);
  }

  // 光源*
  function initLight() {
    let light1 = new THREE.AmbientLight(0xffffff, 1);//环境光，会影响MeshLambertMaterial和MeshPhongMaterial材质
    scene.add(light1);
    // let light2 = new THREE.PointLight(0xffffff, 0.4);//点光
    // light2.position.set(0, 100, 0);
    // scene.add(light2);
    let light3 = new THREE.DirectionalLight(0xffffff, 0.4);//平行光
    light3.position.set(0, 1, 0);
    scene.add(light3);
  }

  // 查看信息小控件
  let stats;

  function initStats() {
    stats = new Stats();
    stats.domElement.style.position = 'absolute';
    stats.domElement.style.left = '0px';
    stats.domElement.style.top = '0px';
    document.getElementById('canvas-frame').appendChild(stats.domElement);
  }

  //添加运动
  function initTween(obj) {
    //声明运动方式
    let tween1 = new TWEEN.Tween(obj.position)
      .to({x: 0, y: 5, rotation: 359}, 1500)
      .easing(TWEEN.Easing.Elastic.InOut);
    let tween2 = new TWEEN.Tween(obj.position)
      .to({x: 3, y: 0, rotation: 0}, 1500)
      .easing(TWEEN.Easing.Elastic.InOut);
    let tween3 = new TWEEN.Tween(obj.position)
      .to({x: 0, y: 0, rotation: 0}, 1500)
      .easing(TWEEN.Easing.Elastic.InOut);
    //运动链式次序
    tween1.chain(tween2);
    tween2.chain(tween3);
    tween3.chain(tween1);
    //执行
    tween1.start();
    // .to( { x: -4}, 3000 ).repeat( Infinity ).start();
  }

  //添加运动
  function initTween1(obj) {
    let tween1 = new TWEEN.Tween(obj.position)
      .to({x: 0, y: 5, z: 3, rotation: 359}, 5500)
      .easing(TWEEN.Easing.Elastic.InOut)
    let tween2 = new TWEEN.Tween(obj.position)
      .to({x: 3, y: 0, z: 3, rotation: 0}, 5500)
      .easing(TWEEN.Easing.Elastic.InOut)
    let tween3 = new TWEEN.Tween(obj.position)
      .to({x: 0, y: 0, z: 3, rotation: 0}, 5500)
      .easing(TWEEN.Easing.Elastic.InOut)
    tween1.chain(tween2);
    tween2.chain(tween3);
    tween3.chain(tween1);
    tween1.start();

    // .to( { x: -4}, 3000 ).repeat( Infinity ).start();
  }

  //以下为物体添加代码---------------------------------------------------------------
  let cube;

  function addCubeBasic() {
    let cubeGeometry = new THREE.CubeGeometry(1, 1, 1);
    let material = new THREE.MeshBasicMaterial({color: 0xcccc00});//材质不受光源影响
    cube = new THREE.Mesh(cubeGeometry, material);
    scene.add(cube);
  }

  function cubeBasicAction() {
    cube.rotation.x += 0.01;
    cube.rotation.y += 0.01;
  }

  let cube2;

  function addCubeLambert() {
    let cubeGeometry = new THREE.CubeGeometry(1, 1, 1);
    let material = new THREE.MeshLambertMaterial({color: 0xa2f4e2});//有光照效果，暗淡不发光
    cube2 = new THREE.Mesh(cubeGeometry, material);
    cube2.position.x = 2;
    scene.add(cube2);
  }

  function cubeLambertAction() {
    cube2.rotation.x += 0.01;
    cube2.rotation.y += 0.01;
  }

  let cube3;

  function addCubePhong() {
    let cubeGeometry = new THREE.CubeGeometry(1, 1, 1);
    let material = new THREE.MeshPhongMaterial({color: 0xff0000});//有光照效果，金属类明亮的物体
    cube3 = new THREE.Mesh(cubeGeometry, material);
    cube3.position.x = 2;
    cube3.position.z = 5;
    scene.add(cube3);
  }

  function cubePhongAction() {
    cube3.rotation.x += 0.01;
    cube3.rotation.y += 0.01;
  }

  let cube4;
  let texture4;

  function addCube4() {
    let cubeGeometry = new THREE.CubeGeometry(10, 10, 10);
    texture4 = new THREE.Texture(canvas);//材质

    let material = new THREE.MeshBasicMaterial({map: texture4});
    cube4 = new THREE.Mesh(cubeGeometry, material);
    cube4.position.x = 16;
    cube4.position.z = -16;
    scene.add(cube4);
  }

  function cube4Action() {
    texture4.needsUpdate = true;
    cube4.rotation.x += 0.001;
    cube4.rotation.y += 0.001;
    cube4.rotation.z += 0.001;
  }

  function addLine() {
    let p1 = new THREE.Vector3(-3, 1, 0);
    let p2 = new THREE.Vector3(8, 1, 0);
    let geometry = new THREE.Geometry();
    geometry.vertices.push(p1);
    geometry.vertices.push(p2);
    let material = new THREE.MeshBasicMaterial({color: 0xcccc00});
    let line = new THREE.LineSegments(geometry, material, THREE.LinePieces);
    scene.add(line);
  }

  // 网格
  function addLines() {
    const gridSize = 100;
    const lineWidth = 4;
    for (let i = 0; i <= gridSize * 2 / lineWidth; i++) {

      let geometry = new THREE.Geometry();
      geometry.vertices.push(new THREE.Vector3(-gridSize, 0, 0));
      geometry.vertices.push(new THREE.Vector3(gridSize, 0, 0));

      let lineX = new THREE.Line(geometry, new THREE.LineBasicMaterial({color: 0xcccccc, opacity: 0.2}));
      lineX.position.z = (i * lineWidth) - gridSize;
      scene.add(lineX);

      let lineY = new THREE.Line(geometry, new THREE.LineBasicMaterial({color: 0xcccccc, opacity: 0.2}));
      lineY.position.x = (i * lineWidth) - gridSize;
      lineY.rotation.y = 90 * Math.PI / 180;   //  旋转90度
      scene.add(lineY);

      // let lineZ = new THREE.Line(geometry, new THREE.LineBasicMaterial({color: 0x0000ff, opacity: 0.5}));
      // lineZ.position.x = (i * 4)-gridSize/2 ;
      // lineZ.rotation.z = 90 * Math.PI / 180;   //  旋转90度
      // scene.add(lineZ);
    }
  }

  //增加几何形状
  function addGeometry1() {
    let geometry = new THREE.PlaneGeometry(10, 6, 1, 1);
    geometry.vertices[0].uv = new THREE.Vector2(0, 0);
    geometry.vertices[1].uv = new THREE.Vector2(1, 0);
    geometry.vertices[2].uv = new THREE.Vector2(2, 2);
    geometry.vertices[3].uv = new THREE.Vector2(0, 2);

    // let texture = THREE.ImageUtils.loadTexture("img/1.gif");
    // let texture = new THREE.TextureLoader().load("img/1.gif");

    let texture = THREE.TextureLoader.prototype.load("img/1.gif");
    let material = new THREE.MeshBasicMaterial({map: texture, side: THREE.DoubleSide});

    let mesh = new THREE.Mesh(geometry, material);
    scene.add(mesh);
    mesh.rotation.x = -0.5 * Math.PI;
    mesh.position.z = -10
  }

  // 初始化基本控件
  initScene();//舞台*
  initCamera();//相机*
  initRenderer();//渲染器*
  initLight();//光源*
  initStats();//监控控件


  addCubeBasic();
  addCubeLambert();
  addCubePhong();
  addLine();
  addLines();
  initTween(cube);
  initTween1(cube2);
  addGeometry1();
  addCube4();

  //循环渲染动作
  (function render() {
    requestAnimationFrame(render);
    cubeBasicAction();
    cubeLambertAction();
    cubePhongAction();
    cube4Action();
    stats.update();
    TWEEN.update();
    controls.update();
    renderer.render(scene, camera);
  })()

  //使渲染器与相机随窗口大小改变适应。自适应窗口大小
  window.onresize = function () {
    console.log(window.innerWidth / window.innerHeight)
    //更新相机视角比例
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }

</script>
</body>
</html>
